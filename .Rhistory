# Define server logic - what do you want the R code to do?
server <- function(input, output) {
#Filter the data using the hwy inputs
filtered_data <- reactive({
df_mpg %>% filter(hwy >= input$mpghwyInput[1] & hwy <= input$mpghwyInput[2])
})
#Create a scatter plot using the x and y axis
output$scatterOutput <-  renderPlot({
xcol <- input$x_axisInput
ycol <- input$y_axisInput
ggplot(filtered_data(), aes_string(x=xcol, y=ycol)) +
geom_point() +
geom_smooth(method='lm',formula=y~x, color='blue')
})
#Run regression
runRegression <- reactive({
lm(as.formula(paste(lm(input$x_axisInput," ~ ",paste(input$y_axisInput,collapse="+"))),data=filtered_data))
}
)
#Histogram
output$residualsOutput <- renderPlot({
hist(residuals(runRegression()), main="", xlab=input$x_axisInput)
})
#Create and return a correlation table
output$correlationOutput <- renderTable({
cor(filtered_data())
})
}
# Run the app
shinyApp(ui = ui, server = server)
# Define server logic - what do you want the R code to do?
server <- function(input, output) {
#Filter the data using the hwy inputs
filtered_data <- reactive({
df_mpg %>% filter(hwy >= input$mpghwyInput[1] & hwy <= input$mpghwyInput[2])
})
#Create a scatter plot using the x and y axis
output$scatterOutput <-  renderPlot({
xcol <- input$x_axisInput
ycol <- input$y_axisInput
ggplot(filtered_data(), aes_string(x=xcol, y=ycol)) +
geom_point() +
geom_smooth(method='lm',formula=y~x, color='blue')
})
#Run regression
Regression <- reactive({
lm(as.formula(paste(input$x_axisInput," ~ ",paste(input$y_axisInput,collapse="+")),data=filtered_data()))
}
)
#Histogram
output$residualsOutput <- renderPlot({
hist(residuals(Regression()), main="", xlab=input$x_axisInput)
})
#Create and return a correlation table
output$correlationOutput <- renderTable({
cor(filtered_data())
})
}
# Run the app
shinyApp(ui = ui, server = server)
# Define server logic - what do you want the R code to do?
server <- function(input, output) {
#Filter the data using the hwy inputs
filtered_data <- reactive({
df_mpg %>% filter(hwy >= input$mpghwyInput[1] & hwy <= input$mpghwyInput[2])
})
#Create a scatter plot using the x and y axis
output$scatterOutput <-  renderPlot({
xcol <- input$x_axisInput
ycol <- input$y_axisInput
ggplot(filtered_data(), aes_string(x=xcol, y=ycol)) +
geom_point() +
geom_smooth(method='lm',formula=y~x, color='blue')
})
#Run regression
Regression <- reactive({
lm(as.formula(paste(input$x_axisInput," ~ ",paste(input$y_axisInput,collapse="+")),data=filtered_data()))
}
)
#Histogram
output$residualsOutput <- renderPlot({
fit <- c(2,5,6,7,4,5,3,2,7,6)
hist(fit, main="", xlab=input$x_axisInput)
})
#Create and return a correlation table
output$correlationOutput <- renderTable({
cor(filtered_data())
})
}
# Run the app
shinyApp(ui = ui, server = server)
# Define server logic - what do you want the R code to do?
server <- function(input, output) {
#Filter the data using the hwy inputs
filtered_data <- reactive({
df_mpg %>% filter(hwy >= input$mpghwyInput[1] & hwy <= input$mpghwyInput[2])
})
#Create a scatter plot using the x and y axis
output$scatterOutput <-  renderPlot({
xcol <- input$x_axisInput
ycol <- input$y_axisInput
ggplot(filtered_data(), aes_string(x=xcol, y=ycol)) +
geom_point() +
geom_smooth(method='lm',formula=y~x, color='blue')
})
#Run regression
fit <- reactive({
lm(input$y_axisInput ~ input$x_axisInput),data=filtered_data()))
}
)
#Histogram
output$residualsOutput <- renderPlot({
fit <- c(2,5,6,7,4,5,3,2,7,6)
hist(fit, main="", xlab=input$x_axisInput)
})
#Create and return a correlation table
output$correlationOutput <- renderTable({
cor(filtered_data())
})
}
# Define server logic - what do you want the R code to do?
server <- function(input, output) {
#Filter the data using the hwy inputs
filtered_data <- reactive({
df_mpg %>% filter(hwy >= input$mpghwyInput[1] & hwy <= input$mpghwyInput[2])
})
#Create a scatter plot using the x and y axis
output$scatterOutput <-  renderPlot({
xcol <- input$x_axisInput
ycol <- input$y_axisInput
ggplot(filtered_data(), aes_string(x=xcol, y=ycol)) +
geom_point() +
geom_smooth(method='lm',formula=y~x, color='blue')
})
#Run regression
fit <- reactive({
lm(input$y_axisInput ~ input$x_axisInput,data=filtered_data())
}
)
#Histogram
output$residualsOutput <- renderPlot({
fit <- c(2,5,6,7,4,5,3,2,7,6)
hist(fit, main="", xlab=input$x_axisInput)
})
#Create and return a correlation table
output$correlationOutput <- renderTable({
cor(filtered_data())
})
}
# Run the app
shinyApp(ui = ui, server = server)
# Define server logic - what do you want the R code to do?
server <- function(input, output) {
#Filter the data using the hwy inputs
filtered_data <- reactive({
df_mpg %>% filter(hwy >= input$mpghwyInput[1] & hwy <= input$mpghwyInput[2])
})
#Create a scatter plot using the x and y axis
output$scatterOutput <-  renderPlot({
xcol <- input$x_axisInput
ycol <- input$y_axisInput
ggplot(filtered_data(), aes_string(x=xcol, y=ycol)) +
geom_point() +
geom_smooth(method='lm',formula=y~x, color='blue')
})
#Run regression
fit <- reactive({
lm(input$y_axisInput ~ input$x_axisInput, data=filtered_data())
}
)
#Histogram
output$residualsOutput <- renderPlot({
fit <- c(2,5,6,7,4,5,3,2,7,6)
hist(residuals(fit()), main="", xlab=input$x_axisInput)
})
#Create and return a correlation table
output$correlationOutput <- renderTable({
cor(filtered_data())
})
}
# Run the app
shinyApp(ui = ui, server = server)
dplyr::mpg
mpg
df_mpg <- mpg %>% filter(hwy >=22 & hwy <= 35)
df_mpg <- select_if(df_mpg, is.numeric)
df_mpg
fit_test <- lm(hwy~ displ, data=df_mpg)
residuals(fit_test)
histogram(residuals(fit_test))
hist(residuals(fit_test))
# Define server logic - what do you want the R code to do?
server <- function(input, output) {
#Filter the data using the hwy inputs
filtered_data <- reactive({
df_mpg %>% filter(hwy >= input$mpghwyInput[1] & hwy <= input$mpghwyInput[2])
})
#Create a scatter plot using the x and y axis
output$scatterOutput <-  renderPlot({
xcol <- input$x_axisInput
ycol <- input$y_axisInput
ggplot(filtered_data(), aes_string(x=xcol, y=ycol)) +
geom_point() +
geom_smooth(method='lm',formula=y~x, color='blue')
})
#Run regression
fit <- reactive({
lm(input$y_axisInput ~ input$x_axisInput, data=filter(df_mpg, hwy >= input$mpghwyInput[1] & hwy <= input$mpghwyInput[2]))
}
)
#Histogram
output$residualsOutput <- renderPlot({
fit <- c(2,5,6,7,4,5,3,2,7,6)
hist(residuals(fit()), main="", xlab=input$x_axisInput)
})
#Create and return a correlation table
output$correlationOutput <- renderTable({
cor(filtered_data())
})
}
# Run the app
shinyApp(ui = ui, server = server)
# Define server logic - what do you want the R code to do?
server <- function(input, output) {
#Filter the data using the hwy inputs
filtered_data <- reactive({
df_mpg %>% filter(hwy >= input$mpghwyInput[1] & hwy <= input$mpghwyInput[2])
})
#Create a scatter plot using the x and y axis
output$scatterOutput <-  renderPlot({
xcol <- input$x_axisInput
ycol <- input$y_axisInput
ggplot(filtered_data(), aes_string(x=xcol, y=ycol)) +
geom_point() +
geom_smooth(method='lm',formula=y~x, color='blue')
})
#Run regression
fit <- reactive({
lm(input$y_axisInput ~ input$x_axisInput, data=filter(df_mpg, hwy >= input$mpghwyInput[1] & hwy <= input$mpghwyInput[2]))
}
)
#Histogram
output$residualsOutput <- renderPlot({
hist(residuals(fit()), main="", xlab=input$x_axisInput)
})
#Create and return a correlation table
output$correlationOutput <- renderTable({
cor(filtered_data())
})
}
# Run the app
shinyApp(ui = ui, server = server)
# Define server logic - what do you want the R code to do?
server <- function(input, output) {
#Filter the data using the hwy inputs
filtered_data <- reactive({
df_mpg %>% filter(hwy >= input$mpghwyInput[1] & hwy <= input$mpghwyInput[2])
})
#Create a scatter plot using the x and y axis
output$scatterOutput <-  renderPlot({
xcol <- input$x_axisInput
ycol <- input$y_axisInput
ggplot(filtered_data(), aes_string(x=xcol, y=ycol)) +
geom_point() +
geom_smooth(method='lm',formula=y~x, color='blue')
})
#Run regression
fit <- reactive({
lm(input$y_axisInput ~ input$x_axisInput,
data=df_mpg)
}
)
#Histogram
output$residualsOutput <- renderPlot({
hist(residuals(fit()), main="", xlab=input$x_axisInput)
})
#Create and return a correlation table
output$correlationOutput <- renderTable({
cor(filtered_data())
})
}
# Run the app
shinyApp(ui = ui, server = server)
summary(fit_test)
residuals(fit_test)
# Define server logic - what do you want the R code to do?
server <- function(input, output) {
#Filter the data using the hwy inputs
filtered_data <- reactive({
df <- df_mpg %>% filter(hwy >= input$mpghwyInput[1] & hwy <= input$mpghwyInput[2])
})
#Create a scatter plot using the x and y axis
output$scatterOutput <-  renderPlot({
xcol <- input$x_axisInput
ycol <- input$y_axisInput
ggplot(filtered_data(), aes_string(x=xcol, y=ycol)) +
geom_point() +
geom_smooth(method='lm',formula=y~x, color='blue')
})
#Run regression
fit <- reactive({
lm(input$y_axisInput ~ input$x_axisInput,
data=df_mpg)
}
)
#Histogram
output$residualsOutput <- renderPlot({
hist(residuals(fit()), main="", xlab=input$x_axisInput)
})
#Create and return a correlation table
output$correlationOutput <- renderTable({
cor(filtered_data())
})
}
# Run the app
shinyApp(ui = ui, server = server)
# Define server logic - what do you want the R code to do?
server <- function(input, output) {
#Filter the data using the hwy inputs
filtered_data <- reactive({
df <- df_mpg %>% filter(hwy >= input$mpghwyInput[1] & hwy <= input$mpghwyInput[2])
})
#Create a scatter plot using the x and y axis
output$scatterOutput <-  renderPlot({
xcol <- input$x_axisInput
ycol <- input$y_axisInput
ggplot(filtered_data(), aes_string(x=xcol, y=ycol)) +
geom_point() +
geom_smooth(method='lm',formula=y~x, color='blue')
})
#Run regression
fit <- reactive({
lm(reformulate(input$x_axisInput, input$y_axisInput), data = filtered_data())
}
)
#Histogram
output$residualsOutput <- renderPlot({
hist(residuals(fit()), main="", xlab=input$x_axisInput)
})
#Create and return a correlation table
output$correlationOutput <- renderTable({
cor(filtered_data())
})
}
# Run the app
shinyApp(ui = ui, server = server)
rm(list=ls())
#Cheatsheet: https://shiny.rstudio.com/images/shiny-cheatsheet.pdf
#Gallyer: https://shiny.rstudio.com/gallery/
df_mpg <- mpg
df_mpg <- select_if(df_mpg, is.numeric)
# Define UI - what do you want your app to look like / contain?
ui <- fluidPage(
titlePanel("Steven Powell"),
sidebarLayout(
sidebarPanel(
"Inputs will go here",
sliderInput("mpghwyInput", "Highway MPG", min(df_mpg$hwy), max(df_mpg$hwy), c(min(df_mpg$hwy), max(df_mpg$hwy))),
selectInput("x_axisInput", "X Axis", colnames(df_mpg), selected="hwy"),
selectInput("y_axisInput", "Y Axis", colnames(df_mpg), selected="displ")
)
,
mainPanel(
h4("Scatter plot and Regression of selected variables"),
plotOutput("scatterOutput"),
br(),
h4("Residuals of Model"),
plotOutput("residualsOutput"),
br(),
h4("Correlation for Filtered Data"),
tableOutput("correlationOutput")
)
)
)
# Define server logic - what do you want the R code to do?
server <- function(input, output) {
#Filter the data using the hwy inputs
filtered_data <- reactive({
df <- df_mpg %>% filter(hwy >= input$mpghwyInput[1] & hwy <= input$mpghwyInput[2])
})
#Create a scatter plot using the x and y axis
output$scatterOutput <-  renderPlot({
xcol <- input$x_axisInput
ycol <- input$y_axisInput
ggplot(filtered_data(), aes_string(x=xcol, y=ycol)) +
geom_point() +
geom_smooth(method='lm',formula=y~x, color='blue')
})
#Run regression
fit <- reactive({
lm(reformulate(input$x_axisInput, input$y_axisInput), data = filtered_data())
}
)
#Histogram
output$residualsOutput <- renderPlot({
hist(residuals(fit()), main="", xlab=input$x_axisInput)
})
#Create and return a correlation table
output$correlationOutput <- renderTable({
cor(filtered_data())
})
}
# Run the app
shinyApp(ui = ui, server = server)
library(haven) #necessary for import of SAS
library(Hmisc) # for rcorr.cens()
library(ROCR) # necessary for performance() func
library(tidyverse) # necessary for life in R
# library(brglm)
rm(list=ls()) # for cleaning global environment, to guarantee a clean slate
path <- getwd()
# IF YOU ARE USING R STUDIO, SKIP THESE AND USE THE AUTOMATED HOTNESS BELOW
# If you aren't using R Studio, chose your path wisely...
# path <- "C:\\Users\\Steven\\Documents\\MSA\\Analytics Foundations\\lab and hw\\Logistic\\logistic-insurance\\"
# path <- "C:\\Users\\Grant\\Downloads\\MSA2019LogisticData\\data\\"
# path <- "C:\\Users\\Bill\\Documents\\NCSU\\Course Work\\Fall\\Logistic Regression\\Final Project\\"
# path <- "C:\\Users\\gavin\\Desktop\\Logisitic_Regression_Data\\"
# path <- "C:\\Users\\molly\\folderino7000\\"
path <- dirname(rstudioapi::getActiveDocumentContext()$path) #AUTOMATED HOTNESS
setwd(path)
load("LogisticsHW1.RData")
############################################
############   DIAGNOSTICS  ################
############################################
#DECISION OF THE FINAL MODEL
final.model <- fit2
############################################
############   ASSESSMENT  #################
############################################
#By S.Powell
# c-statistic
c.stat <- rcorr.cens(fitted(final.model), final.model$y)[1]
c.stat #0.7669765
# Brier score
### Brier score function ###
brier_score <- function(obj, new_x = NULL, new_y = NULL){
# computes [scaled] brier score
#
# inputs:
# 1. obj: either a model from glm() or a data frame.
#         the data frame must have a vector responses "y" and a vector of
#         either probabilities "p" or linear predictor "lp".
# 2. new_x: specify new dataset to get predicted probabilities for new obs.
#             if NULL, the estimated probabilities from original obs will
#             be used.
# 3. new_y: use new responses. if NULL, original ones will be used.
#
# output:
#   brier score, scaled brier score
if(is.null(new_y)){
y <- obj$y
} else {
y <- new_y
}
p_obs <- mean(y)
if(any(class(obj) == "glm")){
if(is.null(new_x)){
p <- predict(obj, newdata = new_x, type = "response")
lp <- predict(obj, newdata = new_x, type = "link")
} else {
lp <- obj$linear
p <- fitted(obj)
}
} else if(is.null(obj$p)) {
lp <- obj$lp
p <- fitted(obj)
} else {
p <- obj$p
lp <- obj$linear
}
# brier score
brier_score <- mean((y - p)^2)
# max brier score is just the observed proportion
brier_max <- p_obs*((1 - p_obs)^2) + (1 - p_obs)*(p_obs^2)
# scaled brier score
# ranges from 0 to 1---lower is better
brier_scaled <- brier_score/brier_max
# essentially, 1 - brier_scaled is the %improvement over null model
res <- data.frame(brier_score = brier_score,
brier_max = brier_max,
brier_scaled = brier_scaled)
res
}
brier_score <- brier_score(final.model)
### ROC curves ###
# the predicted probabilities go first, the actual outcomes (as a factor) second
pred <- prediction(fitted(final.model), factor(final.model$y))
# then in performance, "measure" is the y-axis, and "x.measure" is the x-axis
# for a roc curve, we want tpr vs. fpr. ("sens" and "spec" also work)
perf <- performance(pred, measure = "tpr", x.measure = "fpr")
# Plot of ROC and 45-degree line to reference random guessing
plot(perf, colorize = TRUE)
abline(a = 0, b = 1, lty = 2)
# AUC
auc <- performance(pred, measure = "auc")@y.values
auc == c.stat # Equals c.stat. YAY!
### classification table ###
classif_table <- data.frame(threshold = perf@alpha.values[[1]],
tpr = perf@y.values[[1]],
tnr = 1 - perf@x.values[[1]])
# youden's index: add weights for tpr (sens) and tnr (spec) if desired
classif_table$youdenJ <- with(classif_table, tpr + tnr - 1)
# find row with max
classif_table[which.max(classif_table$youdenJ),]
# TODO coe???cient of discrimination
############################################
##############  SCORING     ################
############################################
#By S.Powell
insurance_v
scores <- predict(final.model, newdata = insurance_v, type = "link")
summary(scores)
